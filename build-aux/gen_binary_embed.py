#!/usr/bin/env python3
# Copyright (c) 2026, WH, All rights reserved.
# Generates source files and a header for embedding binary data in an executable.
#
# Usage:
#   gen_binary_embed.py -t <type> <output> <sym:file> [sym:file] ...
#   gen_binary_embed.py -t <type> <output> -f <manifest>
#
# Types:
#   asm-inline   GCC/Clang inline assembly with .incbin (auto-detects ELF/Mach-O/PE)
#   nasm         NASM assembly (for MSVC, outputs .asm instead of .cpp)
#   cppembed     C++23 #embed directive
#
# A header file (<output_stem>.h) is always generated alongside the source file,
# containing extern "C" declarations and an inline size function for each symbol.
#
# Manifest format (-f / -F):
#   Lines of "symbol:filepath", blank lines and #-comments are ignored.
#   -f manifests have --base-dir prepended to paths; -F manifests don't.

import sys
import os
import argparse

TYPES = ('asm-inline', 'nasm', 'cppembed')


def parse_entries(args_entries, manifest_files, build_manifest_files, base_dir):
    entries = []
    for manifest_file, apply_base in (
        *((m, True) for m in manifest_files),
        *((m, False) for m in build_manifest_files),
    ):
        with open(manifest_file, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                if ':' not in line:
                    print(
                        f'Error: manifest entry must be sym:file, got: {line}', file=sys.stderr)
                    sys.exit(1)
                sym, path = line.split(':', 1)
                path = path.strip()
                if apply_base and base_dir:
                    path = os.path.join(base_dir, path)
                entries.append((sym.strip(), path))
    for entry in args_entries:
        if ':' not in entry:
            print(
                f'Error: entry must be sym:file, got: {entry}', file=sys.stderr)
            sys.exit(1)
        sym, path = entry.split(':', 1)
        entries.append((sym, path))
    if not entries:
        print('Error: no symbol entries specified', file=sys.stderr)
        sys.exit(1)
    return entries


def gen_header(entries):
    lines = [
        '// Auto-generated by gen_binary_embed.py - do not edit',
        '#pragma once',
        '',
        '#include <string_view>',
        '#include <unordered_map>',
        '',
        'extern "C" {',
    ]
    for sym, _ in entries:
        lines.append(f'extern const unsigned char {sym}[];')
        lines.append(f'extern const unsigned char {sym}_end[];')
        lines.append(f'inline unsigned long long {sym}_size() {{ return &{sym}_end[0] - &{sym}[0]; }}') 
    lines.append('} // extern "C"')
    lines.append('')
    lines.append(
        'inline const std::unordered_map<std::string_view, std::string_view> ALL_BINMAP{')
    if len(entries) > 0:
        for sym, _ in entries:
            lines.append('{'f'"{sym}"'', {reinterpret_cast<const char*>('f'&{sym}[0]), reinterpret_cast<const char*>(&{sym}_end[0])''}''},')
        lines[-1] = lines[-1][:-1]
    lines.append('};')
    lines.append('')
    return '\n'.join(lines)


def gen_cppembed(entries):
    lines = [
        '// Auto-generated by gen_binary_embed.py - do not edit',
        '#include <cstddef>',
        '',
        'extern "C" {',
    ]
    for sym, filepath in entries:
        lines.append('')
        lines.append(f'extern const unsigned char {sym}[] = {{')
        lines.append(f'#embed "{filepath}"')
        lines.append('};')
        lines.append(f'extern const unsigned char {sym}_end[1] = {{}};')
    lines.append('')
    lines.append('} // extern "C"')
    lines.append('')
    return '\n'.join(lines)


def gen_asm_inline(entries):
    lines = [
        '// Auto-generated by gen_binary_embed.py - do not edit',
        '',
        '#if defined(__APPLE__) && defined(__MACH__)  // Mach-O',
        '',
    ]
    for sym, filepath in entries:
        lines.append('__asm__(')
        lines.append('    ".section __DATA,__const\\n"')
        lines.append('    ".balign 1\\n"')
        lines.append(f'    ".globl _{sym}\\n"')
        lines.append(f'    "_{sym}:\\n"')
        lines.append(f'    ".incbin \\"{filepath}\\"\\n"')
        lines.append(f'    ".globl _{sym}_end\\n"')
        lines.append(f'    "_{sym}_end:\\n"')
        lines.append('    ".balign 1\\n"')
        lines.append('    ".section __TEXT,__text\\n"')
        lines.append(');')
        lines.append('')
    lines.append('#elif defined(_WIN32)  // MinGW PE/COFF')
    lines.append('')
    lines.append('#ifdef _WIN64')
    lines.append('#define _INCBIN_PFX ""')
    lines.append('#else')
    lines.append('#define _INCBIN_PFX "_"')
    lines.append('#endif')
    lines.append('')
    for sym, filepath in entries:
        lines.append('__asm__(')
        lines.append('    ".section .rdata,\\"dr\\"\\n"')
        lines.append('    ".balign 1\\n"')
        lines.append(f'    ".globl " _INCBIN_PFX "{sym}\\n"')
        lines.append(f'    _INCBIN_PFX "{sym}:\\n"')
        lines.append(f'    ".incbin \\"{filepath}\\"\\n"')
        lines.append(f'    ".globl " _INCBIN_PFX "{sym}_end\\n"')
        lines.append(f'    _INCBIN_PFX "{sym}_end:\\n"')
        lines.append('    ".balign 1\\n"')
        lines.append('    ".section .text\\n"')
        lines.append(');')
        lines.append('')
    lines.append('#undef _INCBIN_PFX')
    lines.append('')
    lines.append('#else  // ELF')
    lines.append('')
    for sym, filepath in entries:
        lines.append('__asm__(')
        lines.append('    ".section .rodata\\n"')
        lines.append('    ".balign 1\\n"')
        lines.append(f'    ".globl {sym}\\n"')
        lines.append(f'    ".type {sym}, @object\\n"')
        lines.append(f'    "{sym}:\\n"')
        lines.append(f'    ".incbin \\"{filepath}\\"\\n"')
        lines.append(f'    ".globl {sym}_end\\n"')
        lines.append(f'    ".type {sym}_end, @object\\n"')
        lines.append(f'    "{sym}_end:\\n"')
        lines.append(f'    ".size {sym}, {sym}_end - {sym}\\n"')
        lines.append('    ".balign 1\\n"')
        lines.append('    ".section \\".text\\"\\n"')
        lines.append(');')
        lines.append('')
    lines.append('#endif')
    lines.append('')
    return '\n'.join(lines)


def gen_nasm(entries):
    lines = [
        '; Auto-generated by gen_binary_embed.py - do not edit',
        'section .data',
    ]
    for sym, filepath in entries:
        lines.append(f'global {sym}')
        lines.append(f'global {sym}_end')
        lines.append(f'{sym}:')
        lines.append(f'    incbin "{filepath}"')
        lines.append(f'{sym}_end:')
    lines.append('')
    return '\n'.join(lines)


def write_if_changed(path, content):
    if os.path.exists(path):
        try:
            with open(path, 'r') as f:
                if f.read() == content:
                    return False
        except:
            pass
    os.makedirs(os.path.dirname(path) or '.', exist_ok=True)
    with open(path, 'w') as f:
        f.write(content)
    return True


def main():
    parser = argparse.ArgumentParser(
        description='Generate source files for embedding binary data in executables.')
    parser.add_argument('-t', '--type', required=True, choices=TYPES,
                        help='Output type: asm-inline, nasm, or cppembed')
    parser.add_argument('-f', '--manifest', metavar='FILE', action='append', default=[],
                        help='Read symbol:filepath entries from a manifest file (can be repeated)')
    parser.add_argument('-F', '--build-manifest', metavar='FILE', action='append', default=[],
                        help='Like -f, but paths are relative to CWD (--base-dir is not applied)')
    parser.add_argument('-b', '--base-dir', default='',
                        help='Base directory to prepend to -f manifest file paths (not -F or CLI entries)')
    parser.add_argument('-d', '--depfile', metavar='FILE',
                        help='Write a Make-format dependency file listing all embedded files')
    parser.add_argument(
        'output', help='Output source file path (.cpp or .asm)')
    parser.add_argument('entries', nargs='*', metavar='sym:file',
                        help='Symbol-to-file mappings')

    args = parser.parse_args()
    entries = parse_entries(args.entries, args.manifest, args.build_manifest, args.base_dir)

    generators = {
        'cppembed': gen_cppembed,
        'asm-inline': gen_asm_inline,
        'nasm': gen_nasm,
    }
    source = generators[args.type](entries)

    # header is the same for all types
    header = gen_header(entries)

    stem, _ = os.path.splitext(args.output)
    header_path = stem + '.h'

    # always write the source file so Make sees a fresh timestamp and recompiles
    # the .o (which picks up embedded file contents via .incbin / #embed)
    os.makedirs(os.path.dirname(args.output) or '.', exist_ok=True)
    with open(args.output, 'w') as f:
        f.write(source)
    # header uses write_if_changed to avoid cascading recompilation
    write_if_changed(header_path, header)

    if args.depfile:
        deps = [filepath for _, filepath in entries] + args.manifest + args.build_manifest
        depfile_content = f'{args.output}: \\\n'
        depfile_content += ' \\\n'.join(f'  {d}' for d in deps)
        depfile_content += '\n'
        write_if_changed(args.depfile, depfile_content)


if __name__ == '__main__':
    main()
